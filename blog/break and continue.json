{"metadata":{"title":"Break and Continue","date":"Dec 27, 2021","excerpt":"A silly thought experiment"},"content":"<p>Consider the following code:</p>\n<pre><code class=\"hljs language-c\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">size_t</span> i = <span class=\"hljs-number\">0</span>; i &#x3C; <span class=\"hljs-number\">100</span>; i++) {\n\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">size_t</span> j = <span class=\"hljs-number\">0</span>; j &#x3C; <span class=\"hljs-number\">100</span>; j++) {\n\t\t<span class=\"hljs-keyword\">if</span> (i > <span class=\"hljs-number\">50</span> &#x26;&#x26; j > <span class=\"hljs-number\">50</span>)\n\t\t\t<span class=\"hljs-keyword\">break</span>;\n\t\tfmt::print(<span class=\"hljs-string\">\"[{},{}]\"</span>, i, j);\n\t}\n\t...\n}\n</code></pre>\n<p>Now imagine we could communicate to the compiler directly that we intend to exit the loops altogether from the break. Currently we'd have to either a) duplicate the break condition or b) use a goto with a label.</p>\n<pre><code class=\"hljs language-c\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">size_t</span> i = <span class=\"hljs-number\">0</span>; i &#x3C; <span class=\"hljs-number\">100</span>; i++) {\n\t<span class=\"hljs-keyword\">size_t</span> j = <span class=\"hljs-number\">0</span>;\n\t<span class=\"hljs-keyword\">for</span> (; j &#x3C; <span class=\"hljs-number\">100</span>; j++) {\n\t\t<span class=\"hljs-keyword\">if</span> (i > <span class=\"hljs-number\">50</span> &#x26;&#x26; j > <span class=\"hljs-number\">50</span>)\n\t\t\t<span class=\"hljs-keyword\">break</span>;\n\t\tfmt::print(<span class=\"hljs-string\">\"[{},{}]\"</span>, i, j);\n\t}\n\t<span class=\"hljs-keyword\">if</span> (i > <span class=\"hljs-number\">50</span> &#x26;&#x26; j > <span class=\"hljs-number\">50</span>)\n\t\t<span class=\"hljs-keyword\">break</span>;\n}\n</code></pre>\n<pre><code class=\"hljs language-c\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">size_t</span> i = <span class=\"hljs-number\">0</span>; i &#x3C; <span class=\"hljs-number\">100</span>; i++) {\n\t<span class=\"hljs-keyword\">size_t</span> j = <span class=\"hljs-number\">0</span>;\n\t<span class=\"hljs-keyword\">for</span> (; j &#x3C; <span class=\"hljs-number\">100</span>; j++) {\n\t\t<span class=\"hljs-keyword\">if</span> (i > <span class=\"hljs-number\">50</span> &#x26;&#x26; j > <span class=\"hljs-number\">50</span>)\n\t\t\t<span class=\"hljs-keyword\">goto</span> stop_this;\n\t\tfmt::print(<span class=\"hljs-string\">\"[{},{}]\"</span>, i, j);\n\t}\n}\nstop_this:\n</code></pre>\n<p>But here's the tricky bit... technically speaking <code>break</code> is nothing more than a contextualized goto. A <code>break</code> statement (in a loop) unconditionally jumps to the exit of a loop. Granted we normally have a condition surrounding it, but the point stands it's not much more than a shorthand for <code>goto</code>. <code>continue</code> also is similar, except that it jumps to the increment condition followed in some way or form the loop condition.</p>\n<p>Suppose we extend c languages in this way <code>break break</code> a break statement which \"breaks\" and then \"breaks\" immediately again. In order to handle the above for example now we could write.</p>\n<pre><code class=\"hljs language-c\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">size_t</span> i = <span class=\"hljs-number\">0</span>; i &#x3C; <span class=\"hljs-number\">100</span>; i++) {\n\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">size_t</span> j = <span class=\"hljs-number\">0</span>; j &#x3C; <span class=\"hljs-number\">100</span>; j++) {\n\t\t<span class=\"hljs-keyword\">if</span> (i > <span class=\"hljs-number\">50</span> &#x26;&#x26; j > <span class=\"hljs-number\">50</span>)\n\t\t\t<span class=\"hljs-keyword\">break</span> <span class=\"hljs-keyword\">break</span>;\n\t\tfmt::print(<span class=\"hljs-string\">\"[{},{}]\"</span>, i, j);\n\t}\n\t...\n}\n</code></pre>\n<p>But of course, we can do better, we can expand this grammatically to escape however nested our loops (or switch statements) happen to be. EG: <code>break break break</code> could exit out a loop that was 3 deep. Now we can easily communicate a fairly neat optimization with no additional keywords.</p>\n<p>How about this? Suppose we allow <code>break continue</code> in a similar fashion such that we can communicate a break statement which \"breaks\" and then \"continues\" immediately afterwards.</p>\n<p>The new c++ grammar would be something like:</p>\n<pre><code class=\"hljs language-txt\">break_stmt:\n\tbreak break_stmt\n\tbreak_stmt continue\n</code></pre>\n<p>This could effectively allow neater hand written code to communicate the intended flow in a loop without jump threading issues.</p>"}
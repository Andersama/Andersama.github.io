<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" type="image/svg" href="/favicon.svg" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />

		<title>unchecked_emplace_back, unchecked_emplace and self_assign</title><link rel="stylesheet" href="/normalize.css" data-svelte="svelte-tloy57"><link rel="stylesheet" href="/skeleton.css" data-svelte="svelte-tloy57"><link rel="stylesheet" href="/atom-dark.css" data-svelte="svelte-tloy57"><script src="/chart.min.js" data-svelte="svelte-tloy57"></script><script src="/chartjs_boxplot/index.umd.js" data-svelte="svelte-tloy57"></script><script src="/chartjs_error_bars/index.umd.js" data-svelte="svelte-tloy57"></script>

		

		<link rel="modulepreload" href="/_app/start-6c6f8217.js">
		<link rel="modulepreload" href="/_app/chunks/vendor-774d9537.js">
		<link rel="modulepreload" href="/_app/chunks/paths-28a87002.js">
		<link rel="modulepreload" href="/_app/pages/__layout.svelte-fd97c867.js">
		<link rel="modulepreload" href="/_app/pages/blog/[slug].svelte-979b54fe.js">
		<link rel="stylesheet" href="/_app/assets/start-61d1577b.css">
		<link rel="stylesheet" href="/_app/assets/pages/__layout.svelte-5e87a37c.css">
		<link rel="stylesheet" href="/_app/assets/pages/blog/[slug].svelte-52f7b3c4.css">

		<script type="module">
			import { start } from "/_app/start-6c6f8217.js";
			start({
				target: document.querySelector("#svelte"),
				paths: {"base":"","assets":""},
				session: {},
				host: location.host,
				route: true,
				spa: false,
				trailing_slash: "never",
				hydrate: {
					status: 200,
					error: null,
					nodes: [
						import("/_app/pages/__layout.svelte-fd97c867.js"),
						import("/_app/pages/blog/[slug].svelte-979b54fe.js")
					],
					page: {
						host: location.host, // TODO this is redundant
						path: "/blog/unchecked_emplace_back unchecked_emplace and self_assign",
						query: new URLSearchParams(""),
						params: {"slug":"unchecked_emplace_back unchecked_emplace and self_assign"}
					}
				}
			});
		</script>
	</head>
	<body>
		<div id="svelte">




<header><div class="container"><nav class="navbar"><a sveltekit:prefetch class="navbar-item navbar-link svelte-fav7xq" href="/">Home</a>
			<a sveltekit:prefetch class="navbar-item navbar-link svelte-fav7xq" href="/about">About</a>
			<a sveltekit:prefetch class="navbar-item navbar-link svelte-fav7xq" href="/activity">Activity</a>
			<a sveltekit:prefetch class="navbar-item navbar-link svelte-fav7xq" href="/gists">Gists</a>
			<a sveltekit:prefetch class="navbar-item navbar-link svelte-fav7xq" href="/cool-repos">Cool Repos</a>
			<a sveltekit:prefetch class="navbar-item navbar-link svelte-fav7xq" href="/blog">Blog</a></nav></div></header>

<main class="container">

<h1 class="title svelte-1mgzh8t">unchecked_emplace_back, unchecked_emplace and self_assign</h1>
<p class="info"><a href="https://github.com/andersama">Andersama</a> AUG 19, 2021</p>
<!-- HTML_TAG_START --><p>Authors:
Alexander Anderson</p>
<h2>Abstract</h2>
<h3>1. Revision History</h3>
<ol start="0">
<li>Initial Draft</li>
</ol>
<p><code>unchecked_emplace_back</code> and <code>unchecked_emplace</code> are variations of two functions which already exist in the standard for several containers. The key difference being these <code>unchecked_</code> variants do not / will not allocate, they assume the capacity of already allocated storage is at least 1 more than the current size. For the purposes of this paper we can consider the signatures to <code>unchecked_emplace_back</code> and <code>unchecked_emplace</code> match those of their "checked" counterparts. The most relevant container is <code>vector</code>, for the purpose of this proposal consider the proposal to add these functions to all containers which function similarly to <code>vector</code>. Assume the worst of these functions in terms of safety, they can and will corrupt data, reach and dereference memory out of bounds and are the essence of running with scissors.</p>
<pre><code class="hljs language-c++"><span class="hljs-comment">//...imagine somewhere buried in MSVC's vector standard header</span>
<span class="hljs-keyword">template</span> &#x3C;class... _Valty>
<span class="hljs-function">_CONSTEXPR20_CONTAINER <span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">unchecked_emplace_back</span><span class="hljs-params">(_Valty &#x26;&#x26;..._Val)</span> </span>{
  <span class="hljs-keyword">return</span> _Emplace_back_with_unused_capacity(_STD forward&#x3C;_Valty>(_Val)...);
}
</code></pre>
<p><code>self_assign</code> is a new function, which is similar to <code>assign</code>, like the above <code>unchecked_</code> functions, <code>self_assign</code> will not allocate. It still "replaces" the containers contents, however <code>self_assign</code> is much more restricted in usage.</p>
<pre><code class="hljs language-c++"><span class="hljs-comment">//...imagine somewhere buried in MSVC's vector standard header</span>
<span class="hljs-keyword">template</span> &#x3C;<span class="hljs-class"><span class="hljs-keyword">class</span> _<span class="hljs-title">Iter</span>></span>
_CONSTEXPR20_CONTAINER <span class="hljs-keyword">void</span> _Self_Assign(_Iter _Last) {
  <span class="hljs-keyword">auto</span> &#x26;   _My_data = _Mypair._Myval2;
  pointer &#x26;_Mylast  = _My_data._Mylast;
  pointer &#x26;_Myend   = _My_data._Myend;

  _Adl_verify_range(_Last, _My_data._Myend);
  _Mylast = _Last;
}

<span class="hljs-keyword">template</span> &#x3C;<span class="hljs-class"><span class="hljs-keyword">class</span> _<span class="hljs-title">Iter</span>, <span class="hljs-title">enable_if_t</span>&#x3C;</span>_Is_iterator_v&#x3C;_Iter>, <span class="hljs-keyword">int</span>> = <span class="hljs-number">0</span>>
_CONSTEXPR20_CONTAINER <span class="hljs-keyword">void</span> <span class="hljs-built_in">self_assign</span>(_Iter _Last) {
  _Self_Assign(_Last);
}
</code></pre>
<pre><code class="hljs language-c++"><span class="hljs-comment">//...perhaps written a bit more human like</span>
<span class="hljs-comment">//...assuming our container's implementation of vector stores three iterators _begin, _end, and _capacity</span>
<span class="hljs-comment">//where size() returns _end - _begin, capacity() returns _capacity and data() and begin() return _begin</span>
<span class="hljs-keyword">template</span> &#x3C;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Iterator</span>, <span class="hljs-title">enable_if_t</span>&#x3C;</span>_Is_iterator_v&#x3C;Iterator>, <span class="hljs-keyword">int</span>> = <span class="hljs-number">0</span>>
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">void</span> <span class="hljs-built_in">self_assign</span>(Iterator last) {
    <span class="hljs-built_in">assert</span>(last >= <span class="hljs-built_in">begin</span>() &#x26;&#x26; last &#x3C;= (<span class="hljs-built_in">begin</span>()+<span class="hljs-built_in">capcity</span>()));
    _end = last;
}
</code></pre>
<p>This example hopefully gives away the rough purpose and usage of <code>self_assign</code>, it is a single parameter function which takes an iterator to the new end of the array. It assumes the memory is already managed, no lifetime management of the data is performed, if <code>self_assign</code> were used to expand the container it will be the responsibility of the maintainer to construct data otherwise if <code>self_assign</code> were used to shrink the container the maintainer is expected to have destroyed data as needed. It also expects the iterator to be within the existing bounds between <code>begin()</code> and <code>begin()+capacity()</code>, this may be (and should be) asserted. It's also a good idea to limit the function to only be enabled if the input type is in fact an iterator.</p>
<h3>2. Motivation</h3>
<p><code>unchecked_emplace_back</code> and <code>unchecked_emplace</code> to a certain degree already exist in most standard library implementations, with these the goal is more or less to present more of the internal utilities already written with performance in mind to the user and to prevent unnecessary workarounds to get to the same performance as the backend has available. Consider below:</p>
<pre><code class="hljs language-c++">std::vector&#x3C;<span class="hljs-keyword">char</span>> a_pseudo_string;
a_pseudo_string.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">32</span>);
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &#x3C; <span class="hljs-number">32</span>; i++) {
  a_pseudo_string.<span class="hljs-built_in">emplace_back</span>(i+<span class="hljs-number">32</span>);
}
</code></pre>
<p>While <code>std::vector&#x3C;char></code> is not <code>std::string</code> and this small snippet is not slow by any stretch of the imagination, parts of this snippet may be relying on some compiler optimizations to kick in. If we're lucky the compiler might notice what we do intuitively in this example which is that we don't need <code>emplace_back</code> to check on the capacity of the vector, even better and more likely is that the compiler will remove the allocation entirely given how many constants are given like this. However the key concept here is that we know, or rather have written a loop to fill our container with data we need, and we don't need to check our container's <code>capacity()</code>.</p>
<pre><code class="hljs language-c++">std::vector&#x3C;<span class="hljs-keyword">char</span>> a_pseudo_string;
a_pseudo_string.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">32</span>);
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &#x3C; <span class="hljs-number">32</span>; i++) {
  <span class="hljs-comment">//does what it says on the tin</span>
  a_pseudo_string.<span class="hljs-built_in">unchecked_emplace_back</span>(i+<span class="hljs-number">32</span>);
}
</code></pre>
<p>We can also roughly imagine similar benefits for calls to <code>emplace</code>, which is the backbone for <code>insert</code>.</p>
<h3>2.1 Current state of affairs</h3>
<p>Here is where things become painful, <code>std::vector</code> is pretty well guarded in that while we may absolutely abuse the access to <code>data()</code> to manipulate any number of indicies, there is no nice way of controlling <code>size()</code>. This makes for an awkwardly lobsided api for anyone wanting or needing to etch out the last bit of performance and try for lower level access. There are no public methods with which we can modify the internals of the container without avoiding unnecessary bounds checking, unnecessary copies, unnecessary construction or destruction calls. If we need to change the <code>size()</code> in order to maintain the validity of the vector after our manipulations, we must pay a higher level cost which may defeat the purpose.</p>
<p>Obviously this is no accident, a well designed api for a class after all should be constrained so that misuse and errors can be handled well. However if we were aiming for safety through and through, we likely shouldn't have <code>operator[]</code> nor <code>data()</code> while we have <code>at()</code>. This paper ideally lends out a hand to all those who work at the lower level so that we don't have to write our own <code>std::vector</code> or similar just to scrape a few % points that are clearly available, or to those who're still very much in love with c and are not afraid of pointer dereferences or array access.</p>
<h3>2.2 The assign approach</h3>
<p>Lets consider what it currently looks like if we wanted to do something similar to <code>unchecked_emplace_back</code>.</p>
<pre><code class="hljs language-c++">std::vector&#x3C;<span class="hljs-keyword">char</span>> a_pseudo_string;
a_pseudo_string.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">32</span>);

<span class="hljs-keyword">char</span> *danger_ptr = a_pseudo_string.<span class="hljs-built_in">data</span>();
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &#x3C; <span class="hljs-number">32</span>; i++) {
  danger_ptr[i] = i+<span class="hljs-number">32</span>;
}
<span class="hljs-comment">// an incredibly awkward use of assign</span>
a_psudo_string.<span class="hljs-built_in">assign</span>(danger_ptr, danger_ptr+<span class="hljs-number">32</span>);
</code></pre>
<p>Depending on the datatypes we're using <code>assign</code> can be extremely penalizing as it can do a full gambit of additional work. Here at least with a bit of trivial data it's not so bad, but anything complex we will end up paying for. <code>assign</code> is designed towards assigning data as quick as humanly possible, an implementation might make self assignment a specialized case to do as little work as possible, however much like the <code>unchecked_</code> variations above we can avoid a branch because we know a bit more about the problem.</p>
<p>When I originally was motivated to modify <code>&#x3C;vector></code> bizzarely it was because I wrote something like the above, but didn't consider anything about <code>assign</code>. I immediately was drawn to the idea of <code>unchecked_emplace_back</code> because I knew it already existed and wouldn't take much work, and my code was absolutely strewn with <code>emplace_back</code>. However as shown above, <code>self_assign</code> also did not take much work. As a bonus it also has a nice looking pattern:</p>
<pre><code class="hljs language-c++">std::vector&#x3C;some_type> buffer;
buffer.<span class="hljs-built_in">reserve</span>(maximum_width);
<span class="hljs-keyword">size_t</span> count = <span class="hljs-number">0</span>;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &#x3C; maximum_width; i++) {
  <span class="hljs-comment">//etc...</span>
}
buffer.<span class="hljs-built_in">self_assign</span>(buffer.<span class="hljs-built_in">data</span>()+count);
</code></pre>
<p>Here, <code>reserve()</code> and <code>self_assign()</code> form their own neatly enclosed block. It can be even better, because in a real example even if we're appending conditionally we can still take advantage of a branchless loop:</p>
<pre><code class="hljs language-c++">std::vector&#x3C;<span class="hljs-keyword">size_t</span>> buffer;
buffer.<span class="hljs-built_in">reserve</span>(maximum_width);
<span class="hljs-keyword">size_t</span> count = <span class="hljs-number">0</span>;
<span class="hljs-comment">//a loop to store odd numbers</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &#x3C; maximum_width; i++) {
  <span class="hljs-comment">//no ifs required, no branches</span>
  <span class="hljs-keyword">bool</span> is_odd = i % <span class="hljs-number">2</span>;
  buffer.<span class="hljs-built_in">data</span>()[count] = i;
  count += is_odd;
}
buffer.<span class="hljs-built_in">self_assign</span>(buffer.<span class="hljs-built_in">data</span>()+count);
</code></pre>
<p>Here we can get something out of <code>self_assign</code> we currently can't out of <code>emplace_back</code> or similar, of course the benefit is solely because we've already saved ourselves a branch and avoided any allocation. If we have to pay for a branch because we have an unknown <code>capacity()</code> requirement, we should be using <code>emplace_back</code>.</p>
<h3>3. Considerations</h3>
<p>All of these functions likely violate some degree of safety which the api has been striving to achieve, namely that they don't just "work". There are specific conditions to their use and they operate in tandem with a well placed <code>reserve()</code>. As someone explained (and I'll need help to cite who because I can't remember) there's an additional difficulty in managing pairs of things. However c and c++ are littered with examples, <code>malloc</code> and <code>free</code>, <code>new</code> and <code>delete</code> and I'm sure a number of others which I also can't remember from the talk. This makes them error prone and are the source of many existing security concerns. In very weird applications the management of these pairs is almost given up entirely, namely in compilers like DMD where the program is simply not meant to be executing for long.</p>
<p>That said these functions are far much more like <code>malloc</code> and <code>free</code>, <code>new</code> and <code>delete</code> in that while they may be "new" to the publicly facing api, <code>unchecked_emplace_back</code> and <code>unchecked_emplace</code> are very much not new, especially to library implementers, nor to anyone who has peaked at a <code>&#x3C;vector></code> header. These utility functions have been lying in the background optimizing edge cases in much the way we might expect.</p>
<p>Of the functions presented <code>self_assign</code> is very much an explicit deviation from the safety oriented api, namely it does obfuscate its ability to modify <code>size()</code>, although I very much think <code>modify_size()</code> would be far more egregious. I would fully expect that <code>self_assign</code> come with assertions for anyone safety conscious. Unlike the <code>unchecked_</code> variations it does in fact provide a new form of functionality, namely that it allows for more complicated (and performant) appends. I don't imagine it would be long for someone to use it for more complicated transformations as well.</p>
<h3>4. Real World</h3>
<p>Wouldn't be too convincing without numbers here's a few quick runs with a benchmark of the earlier examples:</p>
<pre><code class="hljs language-txt">| MSVC x64 debug
|               ns/op |                op/s |    err% |     total | emplace_back benchmark
|--------------------:|--------------------:|--------:|----------:|:----------
|               91.60 |       10,917,030.57 |    0.5% |      0.00 | `emplace_back`
|               31.82 |       31,421,838.18 |    0.4% |      0.00 | `unchecked_emplace_back`
|                9.04 |      110,663,983.90 |    3.4% |      0.00 | `assign`
|                8.65 |      115,606,936.42 |    0.1% |      0.00 | `self_assign`

| MSVC x64 release
|               ns/op |                op/s |    err% |     total | emplace_back benchmark
|--------------------:|--------------------:|--------:|----------:|:----------
|                0.97 |    1,026,392,961.88 |    0.1% |      0.00 | `emplace_back`
|                0.89 |    1,126,637,554.59 |    0.1% |      0.00 | `unchecked_emplace_back`
|                0.57 |    1,741,245,136.19 |    0.1% |      0.00 | `assign`
|                0.53 |    1,899,335,232.67 |    0.0% |      0.00 | `self_assign`

| Clang x64 debug
|               ns/op |                op/s |    err% |     total | emplace_back benchmark
|--------------------:|--------------------:|--------:|----------:|:----------
|               21.06 |       47,483,380.82 |    0.1% |      0.00 | `emplace_back`
|               20.40 |       49,019,607.84 |    0.1% |      0.00 | `unchecked_emplace_back`
|                2.78 |      359,640,359.64 |    0.1% |      0.00 | `assign`
|                2.71 |      369,290,573.37 |    0.0% |      0.00 | `self_assign`

| Clang x64 release
|               ns/op |                op/s |    err% |     total | emplace_back benchmark
|--------------------:|--------------------:|--------:|----------:|:----------
|                1.77 |      564,440,263.41 |    0.1% |      0.00 | `emplace_back`
|                0.80 |    1,256,544,502.62 |    0.2% |      0.00 | `unchecked_emplace_back`
|                0.55 |    1,803,127,874.89 |    0.0% |      0.00 | `assign`
|                0.53 |    1,873,767,258.38 |    0.0% |      0.00 | `self_assign`
</code></pre>
<p>and the code, in the event I've butchered the benchmark. op should roughly translate to the cost of the write of an <code>unsigned int</code>. Strangely enough, and bit of a teaching moment, the assign pattern is the way to go (in debug or release).</p>
<pre><code class="hljs language-c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"vector.h"</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ANKERL_NANOBENCH_IMPLEMENT</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"nanobench.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> ANKERL_NANOBENCH_IMPLEMENT</span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
  ankerl::nanobench::Bench bench;
  
  <span class="hljs-keyword">size_t</span> count = <span class="hljs-number">0</span>;
  <span class="hljs-comment">//to force the compiler to avoid optimizing anything, this should be randomized at runtime</span>
  <span class="hljs-keyword">size_t</span> batch = <span class="hljs-number">1000</span>;
  
  bench.<span class="hljs-built_in">batch</span>(batch);

  <span class="hljs-comment">//increase above 100 ms for more stable results, the performance benefits here are small enough</span>
  <span class="hljs-comment">//that cold runs vary a bit</span>
  <span class="hljs-comment">//bench.minEpochTime(std::chrono::seconds{ 1 });</span>
  
  std::vector&#x3C;<span class="hljs-keyword">uint32_t</span>> buffer;
  buffer.<span class="hljs-built_in">reserve</span>(batch);
  
  bench.<span class="hljs-built_in">run</span>(<span class="hljs-string">"emplace_back"</span>, [&#x26;buffer, &#x26;count, &#x26;batch]() {
    buffer.<span class="hljs-built_in">clear</span>();
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &#x3C; batch; i++) {
      <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span>) {
        buffer.<span class="hljs-built_in">emplace_back</span>(i);
      }
    }
    count += buffer.<span class="hljs-built_in">size</span>();
  });
  
  
  bench.<span class="hljs-built_in">run</span>(<span class="hljs-string">"unchecked_emplace_back"</span>, [&#x26;buffer, &#x26;count, &#x26;batch]() {
    buffer.<span class="hljs-built_in">clear</span>();
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &#x3C; batch; i++) {
      <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span>) {
        buffer.<span class="hljs-built_in">unchecked_emplace_back</span>(i);
      }
    }
    count += buffer.<span class="hljs-built_in">size</span>();
  });
  
  bench.<span class="hljs-built_in">run</span>(<span class="hljs-string">"assign"</span>, [&#x26;buffer, &#x26;count, &#x26;batch]() {
    buffer.<span class="hljs-built_in">clear</span>();
    <span class="hljs-keyword">uint32_t</span>* ptr = buffer.<span class="hljs-built_in">data</span>();
    <span class="hljs-keyword">size_t</span> current = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &#x3C; batch; i++) {
      ptr[current] = i;
      current += (i % <span class="hljs-number">2</span>);
    }
    buffer.<span class="hljs-built_in">assign</span>(buffer.<span class="hljs-built_in">data</span>(), buffer.<span class="hljs-built_in">data</span>() + current);
    count += buffer.<span class="hljs-built_in">size</span>();
  });
  
  bench.<span class="hljs-built_in">run</span>(<span class="hljs-string">"self_assign"</span>, [&#x26;buffer, &#x26;count, &#x26;batch]() {
    buffer.<span class="hljs-built_in">clear</span>();
    <span class="hljs-keyword">uint32_t</span>* ptr = buffer.<span class="hljs-built_in">data</span>();
    <span class="hljs-keyword">size_t</span> current = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &#x3C; batch; i++) {
      ptr[current] = i;
      current += (i % <span class="hljs-number">2</span>);
    }
    buffer.<span class="hljs-built_in">self_assign</span>(buffer.<span class="hljs-built_in">data</span>() + current);
    count += buffer.<span class="hljs-built_in">size</span>();
  });
  
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>Here are some results when we try a benchmark against 1,000,000 ints</p>
<pre><code class="hljs language-txt">| MSVC x64 release
|               ns/op |                op/s |    err% |     total | emplace_back benchmark
|--------------------:|--------------------:|--------:|----------:|:----------
|                0.96 |    1,045,854,271.36 |    0.1% |      0.01 | `emplace_back`
|                0.80 |    1,251,252,505.01 |    0.1% |      0.01 | `unchecked_emplace_back`
|                0.65 |    1,528,457,772.34 |    0.1% |      0.01 | `assign`
|                0.47 |    2,149,774,047.77 |    0.4% |      0.01 | `self_assign`

| Clang x64 release
|               ns/op |                op/s |    err% |     total | emplace_back benchmark
|--------------------:|--------------------:|--------:|----------:|:----------
|                1.58 |      631,572,279.23 |    0.1% |      0.02 | `emplace_back`
|                0.80 |    1,255,035,246.73 |    0.1% |      0.01 | `unchecked_emplace_back`
|                0.70 |    1,430,826,636.05 |    0.6% |      0.01 | `assign`
|                0.53 |    1,883,619,875.31 |    0.3% |      0.01 | `self_assign`
</code></pre>
<p>Here the results are a bit more pronounced, here's some % differences between the earlier tests from Clang.</p>
<pre><code class="hljs language-txt">| Clang x64 release (1000 ints)
|               ns/op |                op/s |    err% |     total | emplace_back benchmark
|--------------------:|--------------------:|--------:|----------:|:----------
|                0.55 |    1,803,127,874.89 |    0.0% |      0.00 | `assign`
|                0.53 |    1,873,767,258.38 |    0.0% |      0.00 | `self_assign`
|--------------------:|--------------------:|--------:|----------:|:----------
| 1,873,767,258.38 / 1,803,127,874.89 = 1.03917 | 3.917% relative speedup

| Clang x64 release (1000000 ints)
|               ns/op |                op/s |    err% |     total | emplace_back benchmark
|--------------------:|--------------------:|--------:|----------:|:----------
|                0.70 |    1,430,826,636.05 |    0.6% |      0.01 | `assign`
|                0.53 |    1,883,619,875.31 |    0.3% |      0.01 | `self_assign`
|--------------------:|--------------------:|--------:|----------:|:----------
| 1,883,619,875.31 / 1,430,826,636.05 = 1.31645 | 31.645% relative speedup

| Clang x64 release (1000 ints)
|               ns/op |                op/s |    err% |     total | emplace_back benchmark
|--------------------:|--------------------:|--------:|----------:|:----------
|                1.77 |      564,440,263.41 |    0.1% |      0.00 | `emplace_back`
|                0.80 |    1,256,544,502.62 |    0.2% |      0.00 | `unchecked_emplace_back`
|--------------------:|--------------------:|--------:|----------:|:----------
| 1,256,544,502.62 / 564,440,263.41 = 2.22617 | 122.617% relative speedup

| Clang x64 release (1000000 ints)
|               ns/op |                op/s |    err% |     total | emplace_back benchmark
|--------------------:|--------------------:|--------:|----------:|:----------
|                1.58 |      631,572,279.23 |    0.1% |      0.02 | `emplace_back`
|                0.80 |    1,255,035,246.73 |    0.1% |      0.01 | `unchecked_emplace_back`
|--------------------:|--------------------:|--------:|----------:|:----------
| 1,255,035,246.73 / 631,572,279.23 = 1.98716 | 98.716% relative speedup
</code></pre>
<p>Note this test when using emplace_back is awful on the branch predictor, but hopefully this illustrates the wide range of performance impact these functions may have.</p><!-- HTML_TAG_END --></main>

<footer class="svelte-fav7xq"><p>© Alex Anderson</p></footer>




			<script type="application/json" data-type="svelte-data" data-url="/blog/unchecked_emplace_back unchecked_emplace and self_assign.json">{"status":200,"statusText":"","headers":{"content-type":"text/plain;charset=UTF-8"},"body":"{\"metadata\":{\"title\":\"unchecked_emplace_back, unchecked_emplace and self_assign\",\"date\":\"Aug 19, 2021\",\"excerpt\":\"A quick std-proposal\"},\"content\":\"\u003Cp\u003EAuthors:\\nAlexander Anderson\u003C\u002Fp\u003E\\n\u003Ch2\u003EAbstract\u003C\u002Fh2\u003E\\n\u003Ch3\u003E1. Revision History\u003C\u002Fh3\u003E\\n\u003Col start=\\\"0\\\"\u003E\\n\u003Cli\u003EInitial Draft\u003C\u002Fli\u003E\\n\u003C\u002Fol\u003E\\n\u003Cp\u003E\u003Ccode\u003Eunchecked_emplace_back\u003C\u002Fcode\u003E and \u003Ccode\u003Eunchecked_emplace\u003C\u002Fcode\u003E are variations of two functions which already exist in the standard for several containers. The key difference being these \u003Ccode\u003Eunchecked_\u003C\u002Fcode\u003E variants do not \u002F will not allocate, they assume the capacity of already allocated storage is at least 1 more than the current size. For the purposes of this paper we can consider the signatures to \u003Ccode\u003Eunchecked_emplace_back\u003C\u002Fcode\u003E and \u003Ccode\u003Eunchecked_emplace\u003C\u002Fcode\u003E match those of their \\\"checked\\\" counterparts. The most relevant container is \u003Ccode\u003Evector\u003C\u002Fcode\u003E, for the purpose of this proposal consider the proposal to add these functions to all containers which function similarly to \u003Ccode\u003Evector\u003C\u002Fcode\u003E. Assume the worst of these functions in terms of safety, they can and will corrupt data, reach and dereference memory out of bounds and are the essence of running with scissors.\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"hljs language-c++\\\"\u003E\u003Cspan class=\\\"hljs-comment\\\"\u003E\u002F\u002F...imagine somewhere buried in MSVC's vector standard header\u003C\u002Fspan\u003E\\n\u003Cspan class=\\\"hljs-keyword\\\"\u003Etemplate\u003C\u002Fspan\u003E &#x3C;class... _Valty\u003E\\n\u003Cspan class=\\\"hljs-function\\\"\u003E_CONSTEXPR20_CONTAINER \u003Cspan class=\\\"hljs-keyword\\\"\u003Edecltype\u003C\u002Fspan\u003E(\u003Cspan class=\\\"hljs-keyword\\\"\u003Eauto\u003C\u002Fspan\u003E) \u003Cspan class=\\\"hljs-title\\\"\u003Eunchecked_emplace_back\u003C\u002Fspan\u003E\u003Cspan class=\\\"hljs-params\\\"\u003E(_Valty &#x26;&#x26;..._Val)\u003C\u002Fspan\u003E \u003C\u002Fspan\u003E{\\n  \u003Cspan class=\\\"hljs-keyword\\\"\u003Ereturn\u003C\u002Fspan\u003E _Emplace_back_with_unused_capacity(_STD forward&#x3C;_Valty\u003E(_Val)...);\\n}\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003E\u003Ccode\u003Eself_assign\u003C\u002Fcode\u003E is a new function, which is similar to \u003Ccode\u003Eassign\u003C\u002Fcode\u003E, like the above \u003Ccode\u003Eunchecked_\u003C\u002Fcode\u003E functions, \u003Ccode\u003Eself_assign\u003C\u002Fcode\u003E will not allocate. It still \\\"replaces\\\" the containers contents, however \u003Ccode\u003Eself_assign\u003C\u002Fcode\u003E is much more restricted in usage.\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"hljs language-c++\\\"\u003E\u003Cspan class=\\\"hljs-comment\\\"\u003E\u002F\u002F...imagine somewhere buried in MSVC's vector standard header\u003C\u002Fspan\u003E\\n\u003Cspan class=\\\"hljs-keyword\\\"\u003Etemplate\u003C\u002Fspan\u003E &#x3C;\u003Cspan class=\\\"hljs-class\\\"\u003E\u003Cspan class=\\\"hljs-keyword\\\"\u003Eclass\u003C\u002Fspan\u003E _\u003Cspan class=\\\"hljs-title\\\"\u003EIter\u003C\u002Fspan\u003E\u003E\u003C\u002Fspan\u003E\\n_CONSTEXPR20_CONTAINER \u003Cspan class=\\\"hljs-keyword\\\"\u003Evoid\u003C\u002Fspan\u003E _Self_Assign(_Iter _Last) {\\n  \u003Cspan class=\\\"hljs-keyword\\\"\u003Eauto\u003C\u002Fspan\u003E &#x26;   _My_data = _Mypair._Myval2;\\n  pointer &#x26;_Mylast  = _My_data._Mylast;\\n  pointer &#x26;_Myend   = _My_data._Myend;\\n\\n  _Adl_verify_range(_Last, _My_data._Myend);\\n  _Mylast = _Last;\\n}\\n\\n\u003Cspan class=\\\"hljs-keyword\\\"\u003Etemplate\u003C\u002Fspan\u003E &#x3C;\u003Cspan class=\\\"hljs-class\\\"\u003E\u003Cspan class=\\\"hljs-keyword\\\"\u003Eclass\u003C\u002Fspan\u003E _\u003Cspan class=\\\"hljs-title\\\"\u003EIter\u003C\u002Fspan\u003E, \u003Cspan class=\\\"hljs-title\\\"\u003Eenable_if_t\u003C\u002Fspan\u003E&#x3C;\u003C\u002Fspan\u003E_Is_iterator_v&#x3C;_Iter\u003E, \u003Cspan class=\\\"hljs-keyword\\\"\u003Eint\u003C\u002Fspan\u003E\u003E = \u003Cspan class=\\\"hljs-number\\\"\u003E0\u003C\u002Fspan\u003E\u003E\\n_CONSTEXPR20_CONTAINER \u003Cspan class=\\\"hljs-keyword\\\"\u003Evoid\u003C\u002Fspan\u003E \u003Cspan class=\\\"hljs-built_in\\\"\u003Eself_assign\u003C\u002Fspan\u003E(_Iter _Last) {\\n  _Self_Assign(_Last);\\n}\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"hljs language-c++\\\"\u003E\u003Cspan class=\\\"hljs-comment\\\"\u003E\u002F\u002F...perhaps written a bit more human like\u003C\u002Fspan\u003E\\n\u003Cspan class=\\\"hljs-comment\\\"\u003E\u002F\u002F...assuming our container's implementation of vector stores three iterators _begin, _end, and _capacity\u003C\u002Fspan\u003E\\n\u003Cspan class=\\\"hljs-comment\\\"\u003E\u002F\u002Fwhere size() returns _end - _begin, capacity() returns _capacity and data() and begin() return _begin\u003C\u002Fspan\u003E\\n\u003Cspan class=\\\"hljs-keyword\\\"\u003Etemplate\u003C\u002Fspan\u003E &#x3C;\u003Cspan class=\\\"hljs-class\\\"\u003E\u003Cspan class=\\\"hljs-keyword\\\"\u003Eclass\u003C\u002Fspan\u003E \u003Cspan class=\\\"hljs-title\\\"\u003EIterator\u003C\u002Fspan\u003E, \u003Cspan class=\\\"hljs-title\\\"\u003Eenable_if_t\u003C\u002Fspan\u003E&#x3C;\u003C\u002Fspan\u003E_Is_iterator_v&#x3C;Iterator\u003E, \u003Cspan class=\\\"hljs-keyword\\\"\u003Eint\u003C\u002Fspan\u003E\u003E = \u003Cspan class=\\\"hljs-number\\\"\u003E0\u003C\u002Fspan\u003E\u003E\\n\u003Cspan class=\\\"hljs-keyword\\\"\u003Econstexpr\u003C\u002Fspan\u003E \u003Cspan class=\\\"hljs-keyword\\\"\u003Evoid\u003C\u002Fspan\u003E \u003Cspan class=\\\"hljs-built_in\\\"\u003Eself_assign\u003C\u002Fspan\u003E(Iterator last) {\\n    \u003Cspan class=\\\"hljs-built_in\\\"\u003Eassert\u003C\u002Fspan\u003E(last \u003E= \u003Cspan class=\\\"hljs-built_in\\\"\u003Ebegin\u003C\u002Fspan\u003E() &#x26;&#x26; last &#x3C;= (\u003Cspan class=\\\"hljs-built_in\\\"\u003Ebegin\u003C\u002Fspan\u003E()+\u003Cspan class=\\\"hljs-built_in\\\"\u003Ecapcity\u003C\u002Fspan\u003E()));\\n    _end = last;\\n}\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EThis example hopefully gives away the rough purpose and usage of \u003Ccode\u003Eself_assign\u003C\u002Fcode\u003E, it is a single parameter function which takes an iterator to the new end of the array. It assumes the memory is already managed, no lifetime management of the data is performed, if \u003Ccode\u003Eself_assign\u003C\u002Fcode\u003E were used to expand the container it will be the responsibility of the maintainer to construct data otherwise if \u003Ccode\u003Eself_assign\u003C\u002Fcode\u003E were used to shrink the container the maintainer is expected to have destroyed data as needed. It also expects the iterator to be within the existing bounds between \u003Ccode\u003Ebegin()\u003C\u002Fcode\u003E and \u003Ccode\u003Ebegin()+capacity()\u003C\u002Fcode\u003E, this may be (and should be) asserted. It's also a good idea to limit the function to only be enabled if the input type is in fact an iterator.\u003C\u002Fp\u003E\\n\u003Ch3\u003E2. Motivation\u003C\u002Fh3\u003E\\n\u003Cp\u003E\u003Ccode\u003Eunchecked_emplace_back\u003C\u002Fcode\u003E and \u003Ccode\u003Eunchecked_emplace\u003C\u002Fcode\u003E to a certain degree already exist in most standard library implementations, with these the goal is more or less to present more of the internal utilities already written with performance in mind to the user and to prevent unnecessary workarounds to get to the same performance as the backend has available. Consider below:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"hljs language-c++\\\"\u003Estd::vector&#x3C;\u003Cspan class=\\\"hljs-keyword\\\"\u003Echar\u003C\u002Fspan\u003E\u003E a_pseudo_string;\\na_pseudo_string.\u003Cspan class=\\\"hljs-built_in\\\"\u003Ereserve\u003C\u002Fspan\u003E(\u003Cspan class=\\\"hljs-number\\\"\u003E32\u003C\u002Fspan\u003E);\\n\u003Cspan class=\\\"hljs-keyword\\\"\u003Efor\u003C\u002Fspan\u003E (\u003Cspan class=\\\"hljs-keyword\\\"\u003Esize_t\u003C\u002Fspan\u003E i = \u003Cspan class=\\\"hljs-number\\\"\u003E0\u003C\u002Fspan\u003E; i &#x3C; \u003Cspan class=\\\"hljs-number\\\"\u003E32\u003C\u002Fspan\u003E; i++) {\\n  a_pseudo_string.\u003Cspan class=\\\"hljs-built_in\\\"\u003Eemplace_back\u003C\u002Fspan\u003E(i+\u003Cspan class=\\\"hljs-number\\\"\u003E32\u003C\u002Fspan\u003E);\\n}\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EWhile \u003Ccode\u003Estd::vector&#x3C;char\u003E\u003C\u002Fcode\u003E is not \u003Ccode\u003Estd::string\u003C\u002Fcode\u003E and this small snippet is not slow by any stretch of the imagination, parts of this snippet may be relying on some compiler optimizations to kick in. If we're lucky the compiler might notice what we do intuitively in this example which is that we don't need \u003Ccode\u003Eemplace_back\u003C\u002Fcode\u003E to check on the capacity of the vector, even better and more likely is that the compiler will remove the allocation entirely given how many constants are given like this. However the key concept here is that we know, or rather have written a loop to fill our container with data we need, and we don't need to check our container's \u003Ccode\u003Ecapacity()\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"hljs language-c++\\\"\u003Estd::vector&#x3C;\u003Cspan class=\\\"hljs-keyword\\\"\u003Echar\u003C\u002Fspan\u003E\u003E a_pseudo_string;\\na_pseudo_string.\u003Cspan class=\\\"hljs-built_in\\\"\u003Ereserve\u003C\u002Fspan\u003E(\u003Cspan class=\\\"hljs-number\\\"\u003E32\u003C\u002Fspan\u003E);\\n\u003Cspan class=\\\"hljs-keyword\\\"\u003Efor\u003C\u002Fspan\u003E (\u003Cspan class=\\\"hljs-keyword\\\"\u003Esize_t\u003C\u002Fspan\u003E i = \u003Cspan class=\\\"hljs-number\\\"\u003E0\u003C\u002Fspan\u003E; i &#x3C; \u003Cspan class=\\\"hljs-number\\\"\u003E32\u003C\u002Fspan\u003E; i++) {\\n  \u003Cspan class=\\\"hljs-comment\\\"\u003E\u002F\u002Fdoes what it says on the tin\u003C\u002Fspan\u003E\\n  a_pseudo_string.\u003Cspan class=\\\"hljs-built_in\\\"\u003Eunchecked_emplace_back\u003C\u002Fspan\u003E(i+\u003Cspan class=\\\"hljs-number\\\"\u003E32\u003C\u002Fspan\u003E);\\n}\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EWe can also roughly imagine similar benefits for calls to \u003Ccode\u003Eemplace\u003C\u002Fcode\u003E, which is the backbone for \u003Ccode\u003Einsert\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\\n\u003Ch3\u003E2.1 Current state of affairs\u003C\u002Fh3\u003E\\n\u003Cp\u003EHere is where things become painful, \u003Ccode\u003Estd::vector\u003C\u002Fcode\u003E is pretty well guarded in that while we may absolutely abuse the access to \u003Ccode\u003Edata()\u003C\u002Fcode\u003E to manipulate any number of indicies, there is no nice way of controlling \u003Ccode\u003Esize()\u003C\u002Fcode\u003E. This makes for an awkwardly lobsided api for anyone wanting or needing to etch out the last bit of performance and try for lower level access. There are no public methods with which we can modify the internals of the container without avoiding unnecessary bounds checking, unnecessary copies, unnecessary construction or destruction calls. If we need to change the \u003Ccode\u003Esize()\u003C\u002Fcode\u003E in order to maintain the validity of the vector after our manipulations, we must pay a higher level cost which may defeat the purpose.\u003C\u002Fp\u003E\\n\u003Cp\u003EObviously this is no accident, a well designed api for a class after all should be constrained so that misuse and errors can be handled well. However if we were aiming for safety through and through, we likely shouldn't have \u003Ccode\u003Eoperator[]\u003C\u002Fcode\u003E nor \u003Ccode\u003Edata()\u003C\u002Fcode\u003E while we have \u003Ccode\u003Eat()\u003C\u002Fcode\u003E. This paper ideally lends out a hand to all those who work at the lower level so that we don't have to write our own \u003Ccode\u003Estd::vector\u003C\u002Fcode\u003E or similar just to scrape a few % points that are clearly available, or to those who're still very much in love with c and are not afraid of pointer dereferences or array access.\u003C\u002Fp\u003E\\n\u003Ch3\u003E2.2 The assign approach\u003C\u002Fh3\u003E\\n\u003Cp\u003ELets consider what it currently looks like if we wanted to do something similar to \u003Ccode\u003Eunchecked_emplace_back\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"hljs language-c++\\\"\u003Estd::vector&#x3C;\u003Cspan class=\\\"hljs-keyword\\\"\u003Echar\u003C\u002Fspan\u003E\u003E a_pseudo_string;\\na_pseudo_string.\u003Cspan class=\\\"hljs-built_in\\\"\u003Ereserve\u003C\u002Fspan\u003E(\u003Cspan class=\\\"hljs-number\\\"\u003E32\u003C\u002Fspan\u003E);\\n\\n\u003Cspan class=\\\"hljs-keyword\\\"\u003Echar\u003C\u002Fspan\u003E *danger_ptr = a_pseudo_string.\u003Cspan class=\\\"hljs-built_in\\\"\u003Edata\u003C\u002Fspan\u003E();\\n\u003Cspan class=\\\"hljs-keyword\\\"\u003Efor\u003C\u002Fspan\u003E (\u003Cspan class=\\\"hljs-keyword\\\"\u003Esize_t\u003C\u002Fspan\u003E i = \u003Cspan class=\\\"hljs-number\\\"\u003E0\u003C\u002Fspan\u003E; i &#x3C; \u003Cspan class=\\\"hljs-number\\\"\u003E32\u003C\u002Fspan\u003E; i++) {\\n  danger_ptr[i] = i+\u003Cspan class=\\\"hljs-number\\\"\u003E32\u003C\u002Fspan\u003E;\\n}\\n\u003Cspan class=\\\"hljs-comment\\\"\u003E\u002F\u002F an incredibly awkward use of assign\u003C\u002Fspan\u003E\\na_psudo_string.\u003Cspan class=\\\"hljs-built_in\\\"\u003Eassign\u003C\u002Fspan\u003E(danger_ptr, danger_ptr+\u003Cspan class=\\\"hljs-number\\\"\u003E32\u003C\u002Fspan\u003E);\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EDepending on the datatypes we're using \u003Ccode\u003Eassign\u003C\u002Fcode\u003E can be extremely penalizing as it can do a full gambit of additional work. Here at least with a bit of trivial data it's not so bad, but anything complex we will end up paying for. \u003Ccode\u003Eassign\u003C\u002Fcode\u003E is designed towards assigning data as quick as humanly possible, an implementation might make self assignment a specialized case to do as little work as possible, however much like the \u003Ccode\u003Eunchecked_\u003C\u002Fcode\u003E variations above we can avoid a branch because we know a bit more about the problem.\u003C\u002Fp\u003E\\n\u003Cp\u003EWhen I originally was motivated to modify \u003Ccode\u003E&#x3C;vector\u003E\u003C\u002Fcode\u003E bizzarely it was because I wrote something like the above, but didn't consider anything about \u003Ccode\u003Eassign\u003C\u002Fcode\u003E. I immediately was drawn to the idea of \u003Ccode\u003Eunchecked_emplace_back\u003C\u002Fcode\u003E because I knew it already existed and wouldn't take much work, and my code was absolutely strewn with \u003Ccode\u003Eemplace_back\u003C\u002Fcode\u003E. However as shown above, \u003Ccode\u003Eself_assign\u003C\u002Fcode\u003E also did not take much work. As a bonus it also has a nice looking pattern:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"hljs language-c++\\\"\u003Estd::vector&#x3C;some_type\u003E buffer;\\nbuffer.\u003Cspan class=\\\"hljs-built_in\\\"\u003Ereserve\u003C\u002Fspan\u003E(maximum_width);\\n\u003Cspan class=\\\"hljs-keyword\\\"\u003Esize_t\u003C\u002Fspan\u003E count = \u003Cspan class=\\\"hljs-number\\\"\u003E0\u003C\u002Fspan\u003E;\\n\u003Cspan class=\\\"hljs-keyword\\\"\u003Efor\u003C\u002Fspan\u003E (\u003Cspan class=\\\"hljs-keyword\\\"\u003Esize_t\u003C\u002Fspan\u003E i = \u003Cspan class=\\\"hljs-number\\\"\u003E0\u003C\u002Fspan\u003E; i &#x3C; maximum_width; i++) {\\n  \u003Cspan class=\\\"hljs-comment\\\"\u003E\u002F\u002Fetc...\u003C\u002Fspan\u003E\\n}\\nbuffer.\u003Cspan class=\\\"hljs-built_in\\\"\u003Eself_assign\u003C\u002Fspan\u003E(buffer.\u003Cspan class=\\\"hljs-built_in\\\"\u003Edata\u003C\u002Fspan\u003E()+count);\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EHere, \u003Ccode\u003Ereserve()\u003C\u002Fcode\u003E and \u003Ccode\u003Eself_assign()\u003C\u002Fcode\u003E form their own neatly enclosed block. It can be even better, because in a real example even if we're appending conditionally we can still take advantage of a branchless loop:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"hljs language-c++\\\"\u003Estd::vector&#x3C;\u003Cspan class=\\\"hljs-keyword\\\"\u003Esize_t\u003C\u002Fspan\u003E\u003E buffer;\\nbuffer.\u003Cspan class=\\\"hljs-built_in\\\"\u003Ereserve\u003C\u002Fspan\u003E(maximum_width);\\n\u003Cspan class=\\\"hljs-keyword\\\"\u003Esize_t\u003C\u002Fspan\u003E count = \u003Cspan class=\\\"hljs-number\\\"\u003E0\u003C\u002Fspan\u003E;\\n\u003Cspan class=\\\"hljs-comment\\\"\u003E\u002F\u002Fa loop to store odd numbers\u003C\u002Fspan\u003E\\n\u003Cspan class=\\\"hljs-keyword\\\"\u003Efor\u003C\u002Fspan\u003E (\u003Cspan class=\\\"hljs-keyword\\\"\u003Esize_t\u003C\u002Fspan\u003E i = \u003Cspan class=\\\"hljs-number\\\"\u003E0\u003C\u002Fspan\u003E; i &#x3C; maximum_width; i++) {\\n  \u003Cspan class=\\\"hljs-comment\\\"\u003E\u002F\u002Fno ifs required, no branches\u003C\u002Fspan\u003E\\n  \u003Cspan class=\\\"hljs-keyword\\\"\u003Ebool\u003C\u002Fspan\u003E is_odd = i % \u003Cspan class=\\\"hljs-number\\\"\u003E2\u003C\u002Fspan\u003E;\\n  buffer.\u003Cspan class=\\\"hljs-built_in\\\"\u003Edata\u003C\u002Fspan\u003E()[count] = i;\\n  count += is_odd;\\n}\\nbuffer.\u003Cspan class=\\\"hljs-built_in\\\"\u003Eself_assign\u003C\u002Fspan\u003E(buffer.\u003Cspan class=\\\"hljs-built_in\\\"\u003Edata\u003C\u002Fspan\u003E()+count);\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EHere we can get something out of \u003Ccode\u003Eself_assign\u003C\u002Fcode\u003E we currently can't out of \u003Ccode\u003Eemplace_back\u003C\u002Fcode\u003E or similar, of course the benefit is solely because we've already saved ourselves a branch and avoided any allocation. If we have to pay for a branch because we have an unknown \u003Ccode\u003Ecapacity()\u003C\u002Fcode\u003E requirement, we should be using \u003Ccode\u003Eemplace_back\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\\n\u003Ch3\u003E3. Considerations\u003C\u002Fh3\u003E\\n\u003Cp\u003EAll of these functions likely violate some degree of safety which the api has been striving to achieve, namely that they don't just \\\"work\\\". There are specific conditions to their use and they operate in tandem with a well placed \u003Ccode\u003Ereserve()\u003C\u002Fcode\u003E. As someone explained (and I'll need help to cite who because I can't remember) there's an additional difficulty in managing pairs of things. However c and c++ are littered with examples, \u003Ccode\u003Emalloc\u003C\u002Fcode\u003E and \u003Ccode\u003Efree\u003C\u002Fcode\u003E, \u003Ccode\u003Enew\u003C\u002Fcode\u003E and \u003Ccode\u003Edelete\u003C\u002Fcode\u003E and I'm sure a number of others which I also can't remember from the talk. This makes them error prone and are the source of many existing security concerns. In very weird applications the management of these pairs is almost given up entirely, namely in compilers like DMD where the program is simply not meant to be executing for long.\u003C\u002Fp\u003E\\n\u003Cp\u003EThat said these functions are far much more like \u003Ccode\u003Emalloc\u003C\u002Fcode\u003E and \u003Ccode\u003Efree\u003C\u002Fcode\u003E, \u003Ccode\u003Enew\u003C\u002Fcode\u003E and \u003Ccode\u003Edelete\u003C\u002Fcode\u003E in that while they may be \\\"new\\\" to the publicly facing api, \u003Ccode\u003Eunchecked_emplace_back\u003C\u002Fcode\u003E and \u003Ccode\u003Eunchecked_emplace\u003C\u002Fcode\u003E are very much not new, especially to library implementers, nor to anyone who has peaked at a \u003Ccode\u003E&#x3C;vector\u003E\u003C\u002Fcode\u003E header. These utility functions have been lying in the background optimizing edge cases in much the way we might expect.\u003C\u002Fp\u003E\\n\u003Cp\u003EOf the functions presented \u003Ccode\u003Eself_assign\u003C\u002Fcode\u003E is very much an explicit deviation from the safety oriented api, namely it does obfuscate its ability to modify \u003Ccode\u003Esize()\u003C\u002Fcode\u003E, although I very much think \u003Ccode\u003Emodify_size()\u003C\u002Fcode\u003E would be far more egregious. I would fully expect that \u003Ccode\u003Eself_assign\u003C\u002Fcode\u003E come with assertions for anyone safety conscious. Unlike the \u003Ccode\u003Eunchecked_\u003C\u002Fcode\u003E variations it does in fact provide a new form of functionality, namely that it allows for more complicated (and performant) appends. I don't imagine it would be long for someone to use it for more complicated transformations as well.\u003C\u002Fp\u003E\\n\u003Ch3\u003E4. Real World\u003C\u002Fh3\u003E\\n\u003Cp\u003EWouldn't be too convincing without numbers here's a few quick runs with a benchmark of the earlier examples:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"hljs language-txt\\\"\u003E| MSVC x64 debug\\n|               ns\u002Fop |                op\u002Fs |    err% |     total | emplace_back benchmark\\n|--------------------:|--------------------:|--------:|----------:|:----------\\n|               91.60 |       10,917,030.57 |    0.5% |      0.00 | `emplace_back`\\n|               31.82 |       31,421,838.18 |    0.4% |      0.00 | `unchecked_emplace_back`\\n|                9.04 |      110,663,983.90 |    3.4% |      0.00 | `assign`\\n|                8.65 |      115,606,936.42 |    0.1% |      0.00 | `self_assign`\\n\\n| MSVC x64 release\\n|               ns\u002Fop |                op\u002Fs |    err% |     total | emplace_back benchmark\\n|--------------------:|--------------------:|--------:|----------:|:----------\\n|                0.97 |    1,026,392,961.88 |    0.1% |      0.00 | `emplace_back`\\n|                0.89 |    1,126,637,554.59 |    0.1% |      0.00 | `unchecked_emplace_back`\\n|                0.57 |    1,741,245,136.19 |    0.1% |      0.00 | `assign`\\n|                0.53 |    1,899,335,232.67 |    0.0% |      0.00 | `self_assign`\\n\\n| Clang x64 debug\\n|               ns\u002Fop |                op\u002Fs |    err% |     total | emplace_back benchmark\\n|--------------------:|--------------------:|--------:|----------:|:----------\\n|               21.06 |       47,483,380.82 |    0.1% |      0.00 | `emplace_back`\\n|               20.40 |       49,019,607.84 |    0.1% |      0.00 | `unchecked_emplace_back`\\n|                2.78 |      359,640,359.64 |    0.1% |      0.00 | `assign`\\n|                2.71 |      369,290,573.37 |    0.0% |      0.00 | `self_assign`\\n\\n| Clang x64 release\\n|               ns\u002Fop |                op\u002Fs |    err% |     total | emplace_back benchmark\\n|--------------------:|--------------------:|--------:|----------:|:----------\\n|                1.77 |      564,440,263.41 |    0.1% |      0.00 | `emplace_back`\\n|                0.80 |    1,256,544,502.62 |    0.2% |      0.00 | `unchecked_emplace_back`\\n|                0.55 |    1,803,127,874.89 |    0.0% |      0.00 | `assign`\\n|                0.53 |    1,873,767,258.38 |    0.0% |      0.00 | `self_assign`\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003Eand the code, in the event I've butchered the benchmark. op should roughly translate to the cost of the write of an \u003Ccode\u003Eunsigned int\u003C\u002Fcode\u003E. Strangely enough, and bit of a teaching moment, the assign pattern is the way to go (in debug or release).\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"hljs language-c++\\\"\u003E\u003Cspan class=\\\"hljs-meta\\\"\u003E#\u003Cspan class=\\\"hljs-meta-keyword\\\"\u003Einclude\u003C\u002Fspan\u003E \u003Cspan class=\\\"hljs-meta-string\\\"\u003E\\\"vector.h\\\"\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\\n\\n\u003Cspan class=\\\"hljs-meta\\\"\u003E#\u003Cspan class=\\\"hljs-meta-keyword\\\"\u003Edefine\u003C\u002Fspan\u003E ANKERL_NANOBENCH_IMPLEMENT\u003C\u002Fspan\u003E\\n\u003Cspan class=\\\"hljs-meta\\\"\u003E#\u003Cspan class=\\\"hljs-meta-keyword\\\"\u003Einclude\u003C\u002Fspan\u003E \u003Cspan class=\\\"hljs-meta-string\\\"\u003E\\\"nanobench.h\\\"\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\\n\u003Cspan class=\\\"hljs-meta\\\"\u003E#\u003Cspan class=\\\"hljs-meta-keyword\\\"\u003Eundef\u003C\u002Fspan\u003E ANKERL_NANOBENCH_IMPLEMENT\u003C\u002Fspan\u003E\\n\\n\u003Cspan class=\\\"hljs-function\\\"\u003E\u003Cspan class=\\\"hljs-keyword\\\"\u003Eint\u003C\u002Fspan\u003E \u003Cspan class=\\\"hljs-title\\\"\u003Emain\u003C\u002Fspan\u003E\u003Cspan class=\\\"hljs-params\\\"\u003E()\u003C\u002Fspan\u003E\\n\u003C\u002Fspan\u003E{\\n  ankerl::nanobench::Bench bench;\\n  \\n  \u003Cspan class=\\\"hljs-keyword\\\"\u003Esize_t\u003C\u002Fspan\u003E count = \u003Cspan class=\\\"hljs-number\\\"\u003E0\u003C\u002Fspan\u003E;\\n  \u003Cspan class=\\\"hljs-comment\\\"\u003E\u002F\u002Fto force the compiler to avoid optimizing anything, this should be randomized at runtime\u003C\u002Fspan\u003E\\n  \u003Cspan class=\\\"hljs-keyword\\\"\u003Esize_t\u003C\u002Fspan\u003E batch = \u003Cspan class=\\\"hljs-number\\\"\u003E1000\u003C\u002Fspan\u003E;\\n  \\n  bench.\u003Cspan class=\\\"hljs-built_in\\\"\u003Ebatch\u003C\u002Fspan\u003E(batch);\\n\\n  \u003Cspan class=\\\"hljs-comment\\\"\u003E\u002F\u002Fincrease above 100 ms for more stable results, the performance benefits here are small enough\u003C\u002Fspan\u003E\\n  \u003Cspan class=\\\"hljs-comment\\\"\u003E\u002F\u002Fthat cold runs vary a bit\u003C\u002Fspan\u003E\\n  \u003Cspan class=\\\"hljs-comment\\\"\u003E\u002F\u002Fbench.minEpochTime(std::chrono::seconds{ 1 });\u003C\u002Fspan\u003E\\n  \\n  std::vector&#x3C;\u003Cspan class=\\\"hljs-keyword\\\"\u003Euint32_t\u003C\u002Fspan\u003E\u003E buffer;\\n  buffer.\u003Cspan class=\\\"hljs-built_in\\\"\u003Ereserve\u003C\u002Fspan\u003E(batch);\\n  \\n  bench.\u003Cspan class=\\\"hljs-built_in\\\"\u003Erun\u003C\u002Fspan\u003E(\u003Cspan class=\\\"hljs-string\\\"\u003E\\\"emplace_back\\\"\u003C\u002Fspan\u003E, [&#x26;buffer, &#x26;count, &#x26;batch]() {\\n    buffer.\u003Cspan class=\\\"hljs-built_in\\\"\u003Eclear\u003C\u002Fspan\u003E();\\n    \u003Cspan class=\\\"hljs-keyword\\\"\u003Efor\u003C\u002Fspan\u003E (\u003Cspan class=\\\"hljs-keyword\\\"\u003Esize_t\u003C\u002Fspan\u003E i = \u003Cspan class=\\\"hljs-number\\\"\u003E0\u003C\u002Fspan\u003E; i &#x3C; batch; i++) {\\n      \u003Cspan class=\\\"hljs-keyword\\\"\u003Eif\u003C\u002Fspan\u003E (i % \u003Cspan class=\\\"hljs-number\\\"\u003E2\u003C\u002Fspan\u003E) {\\n        buffer.\u003Cspan class=\\\"hljs-built_in\\\"\u003Eemplace_back\u003C\u002Fspan\u003E(i);\\n      }\\n    }\\n    count += buffer.\u003Cspan class=\\\"hljs-built_in\\\"\u003Esize\u003C\u002Fspan\u003E();\\n  });\\n  \\n  \\n  bench.\u003Cspan class=\\\"hljs-built_in\\\"\u003Erun\u003C\u002Fspan\u003E(\u003Cspan class=\\\"hljs-string\\\"\u003E\\\"unchecked_emplace_back\\\"\u003C\u002Fspan\u003E, [&#x26;buffer, &#x26;count, &#x26;batch]() {\\n    buffer.\u003Cspan class=\\\"hljs-built_in\\\"\u003Eclear\u003C\u002Fspan\u003E();\\n    \u003Cspan class=\\\"hljs-keyword\\\"\u003Efor\u003C\u002Fspan\u003E (\u003Cspan class=\\\"hljs-keyword\\\"\u003Esize_t\u003C\u002Fspan\u003E i = \u003Cspan class=\\\"hljs-number\\\"\u003E0\u003C\u002Fspan\u003E; i &#x3C; batch; i++) {\\n      \u003Cspan class=\\\"hljs-keyword\\\"\u003Eif\u003C\u002Fspan\u003E (i % \u003Cspan class=\\\"hljs-number\\\"\u003E2\u003C\u002Fspan\u003E) {\\n        buffer.\u003Cspan class=\\\"hljs-built_in\\\"\u003Eunchecked_emplace_back\u003C\u002Fspan\u003E(i);\\n      }\\n    }\\n    count += buffer.\u003Cspan class=\\\"hljs-built_in\\\"\u003Esize\u003C\u002Fspan\u003E();\\n  });\\n  \\n  bench.\u003Cspan class=\\\"hljs-built_in\\\"\u003Erun\u003C\u002Fspan\u003E(\u003Cspan class=\\\"hljs-string\\\"\u003E\\\"assign\\\"\u003C\u002Fspan\u003E, [&#x26;buffer, &#x26;count, &#x26;batch]() {\\n    buffer.\u003Cspan class=\\\"hljs-built_in\\\"\u003Eclear\u003C\u002Fspan\u003E();\\n    \u003Cspan class=\\\"hljs-keyword\\\"\u003Euint32_t\u003C\u002Fspan\u003E* ptr = buffer.\u003Cspan class=\\\"hljs-built_in\\\"\u003Edata\u003C\u002Fspan\u003E();\\n    \u003Cspan class=\\\"hljs-keyword\\\"\u003Esize_t\u003C\u002Fspan\u003E current = \u003Cspan class=\\\"hljs-number\\\"\u003E0\u003C\u002Fspan\u003E;\\n    \u003Cspan class=\\\"hljs-keyword\\\"\u003Efor\u003C\u002Fspan\u003E (\u003Cspan class=\\\"hljs-keyword\\\"\u003Esize_t\u003C\u002Fspan\u003E i = \u003Cspan class=\\\"hljs-number\\\"\u003E0\u003C\u002Fspan\u003E; i &#x3C; batch; i++) {\\n      ptr[current] = i;\\n      current += (i % \u003Cspan class=\\\"hljs-number\\\"\u003E2\u003C\u002Fspan\u003E);\\n    }\\n    buffer.\u003Cspan class=\\\"hljs-built_in\\\"\u003Eassign\u003C\u002Fspan\u003E(buffer.\u003Cspan class=\\\"hljs-built_in\\\"\u003Edata\u003C\u002Fspan\u003E(), buffer.\u003Cspan class=\\\"hljs-built_in\\\"\u003Edata\u003C\u002Fspan\u003E() + current);\\n    count += buffer.\u003Cspan class=\\\"hljs-built_in\\\"\u003Esize\u003C\u002Fspan\u003E();\\n  });\\n  \\n  bench.\u003Cspan class=\\\"hljs-built_in\\\"\u003Erun\u003C\u002Fspan\u003E(\u003Cspan class=\\\"hljs-string\\\"\u003E\\\"self_assign\\\"\u003C\u002Fspan\u003E, [&#x26;buffer, &#x26;count, &#x26;batch]() {\\n    buffer.\u003Cspan class=\\\"hljs-built_in\\\"\u003Eclear\u003C\u002Fspan\u003E();\\n    \u003Cspan class=\\\"hljs-keyword\\\"\u003Euint32_t\u003C\u002Fspan\u003E* ptr = buffer.\u003Cspan class=\\\"hljs-built_in\\\"\u003Edata\u003C\u002Fspan\u003E();\\n    \u003Cspan class=\\\"hljs-keyword\\\"\u003Esize_t\u003C\u002Fspan\u003E current = \u003Cspan class=\\\"hljs-number\\\"\u003E0\u003C\u002Fspan\u003E;\\n    \u003Cspan class=\\\"hljs-keyword\\\"\u003Efor\u003C\u002Fspan\u003E (\u003Cspan class=\\\"hljs-keyword\\\"\u003Esize_t\u003C\u002Fspan\u003E i = \u003Cspan class=\\\"hljs-number\\\"\u003E0\u003C\u002Fspan\u003E; i &#x3C; batch; i++) {\\n      ptr[current] = i;\\n      current += (i % \u003Cspan class=\\\"hljs-number\\\"\u003E2\u003C\u002Fspan\u003E);\\n    }\\n    buffer.\u003Cspan class=\\\"hljs-built_in\\\"\u003Eself_assign\u003C\u002Fspan\u003E(buffer.\u003Cspan class=\\\"hljs-built_in\\\"\u003Edata\u003C\u002Fspan\u003E() + current);\\n    count += buffer.\u003Cspan class=\\\"hljs-built_in\\\"\u003Esize\u003C\u002Fspan\u003E();\\n  });\\n  \\n  \u003Cspan class=\\\"hljs-keyword\\\"\u003Ereturn\u003C\u002Fspan\u003E \u003Cspan class=\\\"hljs-number\\\"\u003E0\u003C\u002Fspan\u003E;\\n}\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EHere are some results when we try a benchmark against 1,000,000 ints\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"hljs language-txt\\\"\u003E| MSVC x64 release\\n|               ns\u002Fop |                op\u002Fs |    err% |     total | emplace_back benchmark\\n|--------------------:|--------------------:|--------:|----------:|:----------\\n|                0.96 |    1,045,854,271.36 |    0.1% |      0.01 | `emplace_back`\\n|                0.80 |    1,251,252,505.01 |    0.1% |      0.01 | `unchecked_emplace_back`\\n|                0.65 |    1,528,457,772.34 |    0.1% |      0.01 | `assign`\\n|                0.47 |    2,149,774,047.77 |    0.4% |      0.01 | `self_assign`\\n\\n| Clang x64 release\\n|               ns\u002Fop |                op\u002Fs |    err% |     total | emplace_back benchmark\\n|--------------------:|--------------------:|--------:|----------:|:----------\\n|                1.58 |      631,572,279.23 |    0.1% |      0.02 | `emplace_back`\\n|                0.80 |    1,255,035,246.73 |    0.1% |      0.01 | `unchecked_emplace_back`\\n|                0.70 |    1,430,826,636.05 |    0.6% |      0.01 | `assign`\\n|                0.53 |    1,883,619,875.31 |    0.3% |      0.01 | `self_assign`\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EHere the results are a bit more pronounced, here's some % differences between the earlier tests from Clang.\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"hljs language-txt\\\"\u003E| Clang x64 release (1000 ints)\\n|               ns\u002Fop |                op\u002Fs |    err% |     total | emplace_back benchmark\\n|--------------------:|--------------------:|--------:|----------:|:----------\\n|                0.55 |    1,803,127,874.89 |    0.0% |      0.00 | `assign`\\n|                0.53 |    1,873,767,258.38 |    0.0% |      0.00 | `self_assign`\\n|--------------------:|--------------------:|--------:|----------:|:----------\\n| 1,873,767,258.38 \u002F 1,803,127,874.89 = 1.03917 | 3.917% relative speedup\\n\\n| Clang x64 release (1000000 ints)\\n|               ns\u002Fop |                op\u002Fs |    err% |     total | emplace_back benchmark\\n|--------------------:|--------------------:|--------:|----------:|:----------\\n|                0.70 |    1,430,826,636.05 |    0.6% |      0.01 | `assign`\\n|                0.53 |    1,883,619,875.31 |    0.3% |      0.01 | `self_assign`\\n|--------------------:|--------------------:|--------:|----------:|:----------\\n| 1,883,619,875.31 \u002F 1,430,826,636.05 = 1.31645 | 31.645% relative speedup\\n\\n| Clang x64 release (1000 ints)\\n|               ns\u002Fop |                op\u002Fs |    err% |     total | emplace_back benchmark\\n|--------------------:|--------------------:|--------:|----------:|:----------\\n|                1.77 |      564,440,263.41 |    0.1% |      0.00 | `emplace_back`\\n|                0.80 |    1,256,544,502.62 |    0.2% |      0.00 | `unchecked_emplace_back`\\n|--------------------:|--------------------:|--------:|----------:|:----------\\n| 1,256,544,502.62 \u002F 564,440,263.41 = 2.22617 | 122.617% relative speedup\\n\\n| Clang x64 release (1000000 ints)\\n|               ns\u002Fop |                op\u002Fs |    err% |     total | emplace_back benchmark\\n|--------------------:|--------------------:|--------:|----------:|:----------\\n|                1.58 |      631,572,279.23 |    0.1% |      0.02 | `emplace_back`\\n|                0.80 |    1,255,035,246.73 |    0.1% |      0.01 | `unchecked_emplace_back`\\n|--------------------:|--------------------:|--------:|----------:|:----------\\n| 1,255,035,246.73 \u002F 631,572,279.23 = 1.98716 | 98.716% relative speedup\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003ENote this test when using emplace_back is awful on the branch predictor, but hopefully this illustrates the wide range of performance impact these functions may have.\u003C\u002Fp\u003E\"}"}</script>
		</div>

		<!-- Default Statcounter code for Github  -->
		<script type="text/javascript">
			var sc_project = 12617424;
			var sc_invisible = 1;
			var sc_security = "3f0e28f6";
		</script>
		<script type="text/javascript" src="https://www.statcounter.com/counter/counter.js" async></script>
		<noscript>
			<div class="statcounter"><a title="Web Analytics" href="https://statcounter.com/" target="_blank"><img
						class="statcounter" src="https://c.statcounter.com/12617424/0/3f0e28f6/1/" alt="Web Analytics"
						referrerPolicy="no-referrer-when-downgrade"></a></div>
		</noscript>
		<!-- End of Statcounter Code -->
	</body>
</html>
